{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Sophia\\\\Downloads\\\\Spring 2025\\\\Capstone Project\\\\CampusConnect_1\\\\capstone-project-campusconnect-team\\\\src\\\\pages\\\\MapNavigation.js\",\n  _s = $RefreshSig$();\n//import react hooks for state management\nimport React, { useEffect, useRef, useCallback, useState } from \"react\";\nimport '../pages/App.css'; // path to import css file for map styling\n\n//log message to track commponent re-renders\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconsole.log(\"MapNavigation re-rendered\"); //debugging log to see if component re-renders\n\n// Debounce function\nconst debounce = (func, wait) => {\n  let timeout;\n  return function (...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait);\n  };\n};\n//MapNavigation component that takes in destination, userLocation, travelMode, and onRouteCalculated as props to display with google maps\nconst MapNavigation = ({\n  destination,\n  userLocation,\n  travelMode,\n  onRouteCalculated\n}) => {\n  _s();\n  //referencefs for Google Maps API elements \n  const mapRef = useRef(null); //reference to map container\n  const directionsServiceRef = useRef(null); //reference to directions service\n  const directionsRendererRef = useRef(null); //reference to directions renderer\n  const mapInstanceRef = useRef(null); //reference to store map instance\n  const originMarkerRef = useRef(null); //reference to origin marker\n  const destinationMarkerRef = useRef(null); //reference to destination marker\n\n  // Use a reference to track if the function has already been called for the same values\n  const lastRouteParams = useRef({\n    destination: null,\n    travelMode: null\n  });\n\n  // Timeout reference for debouncing API calls\n  const routeCache = useRef({});\n\n  //initalize map & directions services only once \n  useEffect(() => {\n    console.log(\"Initializing map...\");\n    //check if google maps API is loaded\n    if (!window.google || !window.google.maps) {\n      console.error(\"Google Maps API not loaded.\");\n      return;\n    }\n\n    //make & store map instance if not yet initialized \n    if (!mapInstanceRef.current) {\n      mapInstanceRef.current = new window.google.maps.Map(mapRef.current, {\n        zoom: 16,\n        //default zoom level\n        center: userLocation || destination,\n        //center map on userLocation or destination\n        disableDefaultUI: false // Prevents UI flickering -> disable default controls\n      });\n      console.log(\"Map initialized:\", mapInstanceRef.current);\n\n      // Initialize DirectionsService (to compute)and DirectionsRenderer (display rendered computed maps) only once\n      directionsServiceRef.current = new window.google.maps.DirectionsService();\n      directionsRendererRef.current = new window.google.maps.DirectionsRenderer({\n        suppressMarkers: true // Prevents automatic markers (fixes flickering)\n      });\n      //set directions render to use our created map instance\n      directionsRendererRef.current.setMap(mapInstanceRef.current);\n    }\n  }, []); //only run once\n\n  // Ensure markers are created only once and update their positions\n  useEffect(() => {\n    if (!mapInstanceRef.current) return; // Exit if map is not initialized\n\n    let AdvancedMarkerElement;\n    try {\n      AdvancedMarkerElement = google.maps.marker.AdvancedMarkerElement; //use advanced marker element\n    } catch (e) {\n      console.warn(\"‚ö†Ô∏è AdvancedMarkerElement not available. Falling back to google.maps.Marker.\");\n    }\n\n    // **Use location marker (A) **\n    if (!originMarkerRef.current && userLocation) {\n      //check if AdvancedMarkerElement is available, if not use google.maps.Marker\n      originMarkerRef.current = AdvancedMarkerElement ? new AdvancedMarkerElement({\n        position: userLocation,\n        //set marker position to user's locarion \n        map: mapInstanceRef.current,\n        //attatched marker to current Map instance\n        title: \"Your Location\",\n        text: \"A\" // Label for the marker\n      }) : new google.maps.Marker({\n        position: userLocation,\n        //fallback to use google.maps.Marker if above fail\n        map: mapInstanceRef.current,\n        title: \"Your Location\",\n        label: \"A\" //fall back to label if advanced marker not available\n      });\n    } else if (originMarkerRef.current) {\n      //update position if marker already created\n      originMarkerRef.current.setPosition(userLocation); //update marker position if already created \n    }\n\n    /* **Use destination marker (B) ** */\n    if (!destinationMarkerRef.current && destination) {\n      destinationMarkerRef.current = AdvancedMarkerElement ? new AdvancedMarkerElement({\n        position: destination,\n        //set marker position to destination\n        map: mapInstanceRef.current,\n        //attatched marker to current Map instance\n        title: \"Destination\",\n        text: \"B\" // Label for the marker\n      }) : new google.maps.Marker({\n        position: destination,\n        map: mapInstanceRef.current,\n        title: \"Destination\",\n        label: \"B\" //fall back to label if advanced marker not available\n      });\n    } else if (destinationMarkerRef.current) {\n      destinationMarkerRef.current.setPosition(destination); //update marker position if already created\n    }\n  }, [userLocation, destination]); // Only update markers if location changes\n\n  // Optimize route calculation -> calculate & display route b/w user location and destination\n  const calculateRoute = useCallback(() => {\n    const cacheKey = `${JSON.stringify(userLocation)}-${JSON.stringify(destination)}-${travelMode}`;\n    if (routeCache.current[cacheKey]) {\n      directionsRendererRef.current.setDirections(routeCache.current[cacheKey]);\n      return;\n    }\n\n    // Exit if any of the required data is missing\n    if (!userLocation || !destination || !directionsServiceRef.current || !directionsRendererRef.current) {\n      return;\n    }\n    console.log(\"üìç Calculating route...\");\n    //direct route rquest parameters \n    const request = {\n      origin: userLocation,\n      //start location\n      destination: destination,\n      //end location\n      travelMode: window.google.maps.TravelMode[travelMode] //travel mode\n    };\n\n    //request route calculation from Google Maps API\n    directionsServiceRef.current.route(request, (result, status) => {\n      if (status === window.google.maps.DirectionsStatus.OK) {\n        directionsRendererRef.current.setDirections(result); //display calculated route\n        routeCache.current[cacheKey] = result; //store route in cache\n\n        // Extract distance and duration\n        const route = result.routes[0].legs[0];\n        const distance = route.distance.text;\n        const duration = route.duration.text;\n        if (onRouteCalculated) {\n          onRouteCalculated({\n            [travelMode.toLowerCase()]: {\n              distance,\n              duration\n            }\n          });\n        }\n\n        // Update lastRouteParams only after a successful calculation\n        lastRouteParams.current = {\n          destination,\n          travelMode\n        };\n      } else {\n        console.error(\"Directions request failed:\", status);\n      }\n    });\n  }, [userLocation, destination, travelMode, onRouteCalculated]);\n  const debouncedCalculateRoute = debounce(calculateRoute, 300);\n  //Call route calculation when travelMode, userLocation, or destination changes\n  //\n  useEffect(() => {\n    if (lastRouteParams.current.destination !== destination || lastRouteParams.current.travelMode !== travelMode) {\n      console.log(\"üìç User changed destination or travel mode. Recalculating route...\");\n      debouncedCalculateRoute();\n    }\n  }, [destination, travelMode, debouncedCalculateRoute]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: mapRef,\n    className: \"map-container\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 174,\n    columnNumber: 12\n  }, this);\n};\n_s(MapNavigation, \"XRnuD+0YQaNgginM7cftdyGZPjQ=\");\n_c = MapNavigation;\nexport default MapNavigation;\nvar _c;\n$RefreshReg$(_c, \"MapNavigation\");","map":{"version":3,"names":["React","useEffect","useRef","useCallback","useState","jsxDEV","_jsxDEV","console","log","debounce","func","wait","timeout","args","clearTimeout","setTimeout","apply","MapNavigation","destination","userLocation","travelMode","onRouteCalculated","_s","mapRef","directionsServiceRef","directionsRendererRef","mapInstanceRef","originMarkerRef","destinationMarkerRef","lastRouteParams","routeCache","window","google","maps","error","current","Map","zoom","center","disableDefaultUI","DirectionsService","DirectionsRenderer","suppressMarkers","setMap","AdvancedMarkerElement","marker","e","warn","position","map","title","text","Marker","label","setPosition","calculateRoute","cacheKey","JSON","stringify","setDirections","request","origin","TravelMode","route","result","status","DirectionsStatus","OK","routes","legs","distance","duration","toLowerCase","debouncedCalculateRoute","ref","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Sophia/Downloads/Spring 2025/Capstone Project/CampusConnect_1/capstone-project-campusconnect-team/src/pages/MapNavigation.js"],"sourcesContent":["//import react hooks for state management\nimport React, { useEffect, useRef, useCallback, useState } from \"react\";\nimport '../pages/App.css'; // path to import css file for map styling\n\n//log message to track commponent re-renders\nconsole.log(\"MapNavigation re-rendered\"); //debugging log to see if component re-renders\n\n// Debounce function\nconst debounce = (func, wait) => {\n    let timeout;\n    return function(...args) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => func.apply(this, args), wait);\n    };\n};\n//MapNavigation component that takes in destination, userLocation, travelMode, and onRouteCalculated as props to display with google maps\nconst MapNavigation = ({ destination, userLocation, travelMode, onRouteCalculated }) => {\n    //referencefs for Google Maps API elements \n    const mapRef = useRef(null); //reference to map container\n    const directionsServiceRef = useRef(null); //reference to directions service\n    const directionsRendererRef = useRef(null); //reference to directions renderer\n    const mapInstanceRef = useRef(null); //reference to store map instance\n    const originMarkerRef = useRef(null); //reference to origin marker\n    const destinationMarkerRef = useRef(null); //reference to destination marker\n\n    // Use a reference to track if the function has already been called for the same values\n    const lastRouteParams = useRef({ destination: null, travelMode: null });\n\n    // Timeout reference for debouncing API calls\n    const routeCache = useRef({});\n\n    //initalize map & directions services only once \n    useEffect(() => {\n        console.log(\"Initializing map...\");\n        //check if google maps API is loaded\n        if (!window.google || !window.google.maps) {\n            console.error(\"Google Maps API not loaded.\");\n            return;\n        }\n\n        //make & store map instance if not yet initialized \n        if (!mapInstanceRef.current) {\n            mapInstanceRef.current = new window.google.maps.Map(mapRef.current, {\n                zoom: 16, //default zoom level\n                center: userLocation || destination, //center map on userLocation or destination\n                disableDefaultUI: false, // Prevents UI flickering -> disable default controls\n            });\n\n        console.log(\"Map initialized:\", mapInstanceRef.current);\n\n        // Initialize DirectionsService (to compute)and DirectionsRenderer (display rendered computed maps) only once\n        directionsServiceRef.current = new window.google.maps.DirectionsService();\n        directionsRendererRef.current = new window.google.maps.DirectionsRenderer({\n            suppressMarkers: true, // Prevents automatic markers (fixes flickering)\n        });\n            //set directions render to use our created map instance\n            directionsRendererRef.current.setMap(mapInstanceRef.current);\n    }\n    }, []); //only run once\n\n        // Ensure markers are created only once and update their positions\n        useEffect(() => {\n            if (!mapInstanceRef.current) return; // Exit if map is not initialized\n\n            let AdvancedMarkerElement;\n            try {\n                AdvancedMarkerElement = google.maps.marker.AdvancedMarkerElement; //use advanced marker element\n            } catch (e) {\n                console.warn(\"‚ö†Ô∏è AdvancedMarkerElement not available. Falling back to google.maps.Marker.\");\n            }\n    \n            // **Use location marker (A) **\n            if (!originMarkerRef.current && userLocation) {\n                //check if AdvancedMarkerElement is available, if not use google.maps.Marker\n                originMarkerRef.current = AdvancedMarkerElement\n                    ? new AdvancedMarkerElement({\n                          position: userLocation, //set marker position to user's locarion \n                          map: mapInstanceRef.current, //attatched marker to current Map instance\n                          title: \"Your Location\",\n                          text: \"A\", // Label for the marker\n                      })\n                    : new google.maps.Marker({\n                          position: userLocation, //fallback to use google.maps.Marker if above fail\n                          map: mapInstanceRef.current,\n                          title: \"Your Location\",\n                          label: \"A\", //fall back to label if advanced marker not available\n                      });\n            } else if (originMarkerRef.current) {\n                //update position if marker already created\n                originMarkerRef.current.setPosition(userLocation); //update marker position if already created \n            }\n    \n            /* **Use destination marker (B) ** */\n            if (!destinationMarkerRef.current && destination) {\n                destinationMarkerRef.current = AdvancedMarkerElement\n                    ? new AdvancedMarkerElement({\n                          position: destination, //set marker position to destination\n                          map: mapInstanceRef.current, //attatched marker to current Map instance\n                          title: \"Destination\",\n                          text: \"B\", // Label for the marker\n                      })\n                    : new google.maps.Marker({\n                          position: destination,\n                          map: mapInstanceRef.current,\n                          title: \"Destination\",\n                          label: \"B\", //fall back to label if advanced marker not available\n                      });\n            } else if (destinationMarkerRef.current) {\n                destinationMarkerRef.current.setPosition(destination); //update marker position if already created\n            }\n\n        }, [userLocation, destination]); // Only update markers if location changes\n\n    \n    // Optimize route calculation -> calculate & display route b/w user location and destination\n        const calculateRoute = useCallback(() => {\n            const cacheKey = `${JSON.stringify(userLocation)}-${JSON.stringify(destination)}-${travelMode}`;\n            if (routeCache.current[cacheKey]) {\n                directionsRendererRef.current.setDirections(routeCache.current[cacheKey]);\n                return;\n            }\n\n            // Exit if any of the required data is missing\n            if (!userLocation || !destination || !directionsServiceRef.current || !directionsRendererRef.current) {\n                return;\n            }\n\n            console.log(\"üìç Calculating route...\");\n            //direct route rquest parameters \n            const request = {\n                origin: userLocation, //start location\n                destination: destination, //end location\n                travelMode: window.google.maps.TravelMode[travelMode], //travel mode\n            };\n\n            //request route calculation from Google Maps API\n            directionsServiceRef.current.route(request, (result, status) => {\n                if (status === window.google.maps.DirectionsStatus.OK) {\n                    directionsRendererRef.current.setDirections(result); //display calculated route\n                    routeCache.current[cacheKey] = result; //store route in cache\n\n                    // Extract distance and duration\n                    const route = result.routes[0].legs[0];\n                    const distance = route.distance.text;\n                    const duration = route.duration.text;\n\n                    if (onRouteCalculated) {\n                        onRouteCalculated({ [travelMode.toLowerCase()]: { distance, duration } });\n                    }\n\n                    // Update lastRouteParams only after a successful calculation\n                    lastRouteParams.current = { destination, travelMode };\n                    } else {\n                        console.error(\"Directions request failed:\", status);\n                    }\n            });\n        \n        }, [userLocation, destination, travelMode, onRouteCalculated]);\n\n        const debouncedCalculateRoute = debounce(calculateRoute, 300);\n    //Call route calculation when travelMode, userLocation, or destination changes\n    //\n    useEffect(() => {\n    \n        if (\n            lastRouteParams.current.destination !== destination ||\n            lastRouteParams.current.travelMode !== travelMode\n        ) {\n            console.log(\"üìç User changed destination or travel mode. Recalculating route...\");\n            debouncedCalculateRoute();\n        }\n    }, [destination, travelMode, debouncedCalculateRoute]);\n\n    return <div ref={mapRef} className=\"map-container\" />;\n    \n};\n\nexport default MapNavigation;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}